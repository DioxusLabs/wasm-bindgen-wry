class JSHeap{slots;freeIds;maxId;constructor(){this.slots=[],this.freeIds=[],this.maxId=0}insert(value){let id;if(this.freeIds.length>0)id=this.freeIds.pop();else id=this.maxId,this.maxId++;return this.slots[id]=value,id}get(id){return this.slots[id]}remove(id){let value=this.slots[id];if(value!==void 0)this.slots[id]=void 0,this.freeIds.push(id);return value}has(id){return this.slots[id]!==void 0}serialize(value){return{type:"js_heap_ref",id:this.insert(value)}}}var jsHeap=new JSHeap;function sync_request(endpoint,contents){let xhr=new XMLHttpRequest;xhr.open("POST",endpoint,!1),xhr.setRequestHeader("Content-Type","application/json");let json_string=JSON.stringify(contents);console.log("Sending request to Rust:",json_string);let contents_bytes=new TextEncoder().encode(json_string),contents_base64=btoa(String.fromCharCode.apply(null,contents_bytes));xhr.setRequestHeader("dioxus-data",contents_base64),xhr.send();let response_text=xhr.responseText;console.log("Received response from Rust:",response_text);try{return JSON.parse(response_text)}catch(e){return console.error("Failed to parse response JSON:",e),null}}function run_code(code,args){let f;switch(code){case 0:f=console.log;break;case 1:f=alert;break;case 2:f=(a,b)=>a+b;break;case 3:f=(event_name,callback)=>{document.addEventListener(event_name,(e)=>{if(callback.call())e.preventDefault(),console.log("Event "+event_name+" default prevented by Rust callback.")})};break;case 4:f=(element_id,text_content)=>{let element=document.getElementById(element_id);if(element)element.textContent=text_content;else console.warn("Element with ID "+element_id+" not found.")};break;case 5:f=(value)=>{return{type:"js_heap_ref",id:jsHeap.insert(value)}};break;case 6:f=(value)=>value;break;case 7:f=(id)=>jsHeap.remove(id);break;case 8:f=(id)=>jsHeap.has(id);break;case 9:f=(props)=>{return{type:"js_heap_ref",id:jsHeap.insert(props)}};break;case 10:f=(obj,key)=>obj[key];break;case 11:f=(obj,key,value)=>{obj[key]=value};break;case 12:f=(obj,method,methodArgs)=>{let fn=obj[method];if(typeof fn==="function")return fn.apply(obj,methodArgs);throw new Error("Method "+method+" is not a function")};break;case 13:f=()=>document.body;break;case 14:f=(selector)=>document.querySelector(selector);break;case 15:f=(tag)=>document.createElement(tag);break;case 16:f=(parent,child)=>{parent.appendChild(child)};break;case 17:f=(el,name,value)=>el.setAttribute(name,value);break;case 18:f=(el,text)=>{el.textContent=text};break;default:throw new Error("Unknown code: "+code)}return f.apply(null,args)}function evaluate_from_rust(code,args_json){let args=deserialize_args(args_json),result=run_code(code,args),response={Respond:{response:serialize_return(result)}},request_result=sync_request("wry://handler",response);return handleResponse(request_result)}function deserialize_args(args_json){if(typeof args_json==="string")return args_json;else if(typeof args_json==="number")return args_json;else if(Array.isArray(args_json))return args_json.map(deserialize_args);else if(typeof args_json==="object"&&args_json!==null)if(args_json.type==="function")return new RustFunction(args_json.id);else if(args_json.type==="js_heap_ref"){let id=args_json.id,value=jsHeap.get(id);if(value===void 0)console.warn("JSHeap reference with ID "+id+" not found.");return value}else{let obj={};for(let key in args_json)obj[key]=deserialize_args(args_json[key]);return obj}}function serialize_return(value){if(value===null||value===void 0)return null;if(typeof value==="string"||typeof value==="number"||typeof value==="boolean")return value;if(Array.isArray(value))return value.map(serialize_return);if(typeof value==="object"){let obj=value;if(obj.type==="js_heap_ref"&&typeof obj.id==="number")return value;if(Object.getPrototypeOf(value)===Object.prototype){let result={};for(let key in obj)result[key]=serialize_return(obj[key]);return result}return jsHeap.serialize(value)}return null}function handleResponse(response){if(!response)return;if(console.log("Handling response:",response),response.Respond)return response.Respond.response;else if(response.Evaluate)return evaluate_from_rust(response.Evaluate.fn_id,response.Evaluate.args);else throw new Error("Unknown response type")}class RustFunction{code;constructor(code){this.code=code}call(...args){let response=sync_request("wry://handler",{Evaluate:{fn_id:this.code,args}});return handleResponse(response)}}window.evaluate_from_rust=evaluate_from_rust;window.jsHeap=jsHeap;
